def ToObject(
  argument: ESValue,
): Normal[Object] | Abrupt[throw] = {
  if (= (typeof argument) @Undefined) {
    call %0 = clo<__NEW_ERROR_OBJ__>("%TypeError.prototype%")
    call %1 = clo<ThrowCompletion>(%0)
    return %1
  }
  if (= (typeof argument) @Null) {
    call %2 = clo<__NEW_ERROR_OBJ__>("%TypeError.prototype%")
    call %3 = clo<ThrowCompletion>(%2)
    return %3
  }
  if (= (typeof argument) @Boolean) {
    return (new OrdinaryObject { "Prototype" : @EXECUTION_STACK[0].Realm.Intrinsics["%Boolean.prototype%"], "BooleanData" : argument, "Extensible" : true })
  }
  if (= (typeof argument) @Number) {
    return (new OrdinaryObject { "Prototype" : @EXECUTION_STACK[0].Realm.Intrinsics["%Number.prototype%"], "NumberData" : argument, "Extensible" : true })
  }
  if (= (typeof argument) @String) {
    let obj = (new StringExoticObject { "Prototype" : @EXECUTION_STACK[0].Realm.Intrinsics["%String.prototype%"], "StringData" : argument, "Extensible" : true })
    obj.__MAP__.length = (new PropertyDescriptor { "Value" : ([number] argument.length), "Writable" : false, "Enumerable" : false, "Configurable" : false })
    return obj
  }
  if (= (typeof argument) @Symbol) {
    let obj = (new OrdinaryObject { "Prototype" : @EXECUTION_STACK[0].Realm.Intrinsics["%Symbol.prototype%"], "SymbolData" : argument, "Extensible" : true })
    return obj
  }
  if (= (typeof argument) @BigInt) {
    let obj = (new OrdinaryObject { "Prototype" : @EXECUTION_STACK[0].Realm.Intrinsics["%BigInt.prototype%"], "BigIntData" : argument, "Extensible" : true })
    return obj
  }
  if (= (typeof argument) @Object) return argument
  assert false
}
